In this chapter the client and it's funcitions are descibed. How the Client exaclty works is describe in this chapter.\\

The client is divided in different parts.
\small {
\begin{enumerate}[noitemsep, nolistsep]
	\item 	\textbf{MQTT}
	\item 	\textbf{Message/Config Parser}
	\item	\textbf{Music}
	\item	\textbf{Relative Weight Factor(RWF)}
	\item 	\textbf{Log}
\end{enumerate}
}

The parts will be explained in the next sections.

\section{MQTT}

The client use the \href{http://mosquitto.org/}{Mosquitto MQTT C++ library.} This is an open source message broker that implements the MQTT protocol versions 3.1 and 3.1.1. MQTT provides a lightweight methode of carring out messages using a publish/subsribed model. This makes it suitable for \say{Internet of Things} messaging.\\

The client and the website use topics to communicate. The topics for the communication are discribed in the previous chapter. The DNS class has an public inheritance of the Mosquito class. This means all public and protected members of the Mosquitto can be accessed by the DNS class. The private members cannot directly accessed by DNS class. In the DNS class the Mosquitto functions are been overwritten by our own implementation. The Mosquitto functions are automatically called by the Mosquitto library.\\

If the client is excuted the Mosquitto library calls the function  
\textbf{ on connect}. This function published the client-id in the \textbf{online topic } and subsribes itself on the following topics:
\small{
\begin{itemize} [noitemsep, nolistsep]
	\item \textbf {request online}
	\item \textbf {request client data}
	\item \textbf {clients data}
	\item \textbf {music volume}
	\item \textbf {music status}
	\item \textbf {music sources\\}
\end{itemize}
}

If the client is stopped or disconnected the Mosquitto library calls the function \textbf {on disconnect}. This function published the client-id in the \textbf {offline topic}.\\

When the client is running and has excuted the function \textbf {on connect}. He waits on a message from a subscribed topic. If there appears a message, the function \textbf {on message} is called. This function has as parameters a mosquitto message struct. This contains: 
\small{
\begin{itemize} [noitemsep, nolistsep]
	\item \textbf {int mid}
	\item \textbf {char *topic}
	\item \textbf {void* payload}
	\item \textbf {int payloadlen}
	\item \textbf {int qos}
	\item \textbf {bool retain\\}
\end{itemize}
}

In the function is watched on which topic a message is send. This is done by compare the \textbf {char *topic} of the mosquitto message struct with the defined topic described in chapter 2. When there is a match, a action is carried out.\\

MQTT has a funcion that is called \textbf {last will}. This function is called when a client abruptly disconnected and published his last will message. This can means that the client crashed, hasn't a connection to the broker or something else. In the client this function is implemented and the client will publish his message to the \textbf {offline} topic.

\section{Message/Config Parser}

Almost all the messages that are been send in this application are in \href{http://www.json.org/}{JSON string format}. In C++ this is a bit difficult because the native language doesn't include a JSON Parser. In the client the \href{https://github.com/Zguy/Jzon}{library JZON} is used to parse the JSON string formats.\\

The client must be provided with a file with data in JSON format to be used to initialize the client. The data that can be specified is:
\small{
\begin{itemize} [noitemsep, nolistsep]
	\item \textbf {Names}
	\item \textbf {Log info}
	\item \textbf {Prefixs}
	\item \textbf {Brokers}
	\item \textbf {Topics\\}
\end{itemize}
}
With this it's possible to define the data mentioned above in the config file and it can be used to initialize the clients and the website. The benefits of doing this is that you only have to change the config file and everything still works instead of changing every client individually.

